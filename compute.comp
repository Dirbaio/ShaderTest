#version 430

struct block {
    vec4 color;
};

layout(std140, binding=1) buffer blocksBuffer {
    block blocks [];
};

uniform vec3 eyePos;
uniform vec3 camForward;
uniform vec3 camUp;

uniform image2D destTex;

layout (local_size_x = 16, local_size_y = 16) in;

bool getBlock(int x, int y, int z)
{
    if(min(x, min(y, z)) < 0) return false;
    if(max(x, max(y, z)) >= 32) return false;
    int ind = x+y*32+z*32*32;
    if(blocks[ind].color.a < 0.5) return false;
    return true;
}


/*
void World::traceView(const Player *playerCam, float tMax) {
    if (!getOutOfBounds(floor(playerCam->camPos.x),floor(playerCam->camPos.y),floor(playerCam->camPos.z)) &&
            getCube(floor(playerCam->camPos.x),floor(playerCam->camPos.y),floor(playerCam->camPos.z)).ID != 0) {
        playerTargetsBlock = true;
        targetedBlock = vec3f(floor(playerCam->camPos.x),floor(playerCam->camPos.y),floor(playerCam->camPos.z));
        return;
    }
}
*/

void main()
{
    ivec2 storePos = ivec2(gl_GlobalInvocationID.xy);
    vec2 p = storePos*(2.0/1024.0)-1.0;

    //Calculate ray
    vec3 vCamForward = normalize(camForward);
    vec3 vCamRight = normalize(cross(camForward, camUp));
    vec3 vCamUp = normalize(cross(vCamRight, camForward));
    vec3 dir = normalize(vCamForward + vCamUp*p.y + vCamRight*p.x);
    vec3 pos = eyePos;

    //Setup raycast
    vec3 vox = vec3(floor(pos.x), floor(pos.y), floor(pos.z));
    vec3 step = vec3(0,0,0);
    vec3 next = vec3(0,0,0);

    float tMax = 100; //Max distance
    vec3 tMaxc = vec3(tMax,tMax,tMax);
    vec3 tDelta = vec3(tMax,tMax,tMax);

    if (dir.x < 0) step.x = -1;
    else step.x = 1;
    if (dir.y < 0) step.y = -1;
    else step.y = 1;
    if (dir.z < 0) step.z = -1;
    else step.z = 1;

    next.x = vox.x + (step.x > 0 ? 1 : 0);
    next.y = vox.y + (step.y > 0 ? 1 : 0);
    next.z = vox.z + (step.z > 0 ? 1 : 0);

    if (dir.x != 0) {
        tDelta.x = step.x/dir.x;
        tMaxc.x = (next.x - pos.x)/dir.x;
    }
    if (dir.y != 0) {
        tDelta.y = step.y/dir.y;
        tMaxc.y = (next.y - pos.y)/dir.y;
    }
    if (dir.z != 0) {
        tDelta.z = step.z/dir.z;
        tMaxc.z = (next.z - pos.z)/dir.z;
    }

    bool running = true;
    float tCurr = 0;
    float light = 0;
    while (tCurr < tMax && running) {
        if(tMaxc.x < tMaxc.y) {
            if(tMaxc.x < tMaxc.z) {
                tCurr = tMaxc.x;
                tMaxc.x = tMaxc.x + tDelta.x;
                vox.x = vox.x + step.x;
                light = 1.0;
            }
            else {
                tCurr = tMaxc.z;
                vox.z = vox.z + step.z;
                tMaxc.z = tMaxc.z + tDelta.z;
                light = 0.4;
            }
        }
        else {
            if(tMaxc.y < tMaxc.z) {
                tCurr = tMaxc.y;
                vox.y = vox.y + step.y;
                tMaxc.y = tMaxc.y + tDelta.y;
                light = 0.7;
            }
            else {
                tCurr = tMaxc.z;
                vox.z = vox.z + step.z;
                tMaxc.z = tMaxc.z + tDelta.z;
                light = 0.4;
            }
        }
        if(getBlock(int(vox.x),int(vox.y),int(vox.z))) {
//            targetedBlock = vox;
            running = false;
        }
    }

    vec4 col = vec4(0, 0, 0, 1); //blocks[int(abs(dir.x+dir.y+dir.z)*20)];

    if(!running) //Raytracing hit
    {
        int x = int(vox.x);
        int y = int(vox.y);
        int z = int(vox.z);
        int ind = x+y*32+z*32*32;

        col = vec4(blocks[ind].color.rgb*light, 1.0);
    }

    imageStore(destTex, storePos, col);
}
